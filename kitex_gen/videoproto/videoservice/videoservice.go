// Code generated by Kitex v0.3.1. DO NOT EDIT.

package videoservice

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"google.golang.org/protobuf/proto"
	videoproto2 "simple-douyin/kitex_gen/videoproto"
)

func serviceInfo() *kitex.ServiceInfo {
	return videoServiceServiceInfo
}

var videoServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "VideoService"
	handlerType := (*videoproto2.VideoService)(nil)
	methods := map[string]kitex.MethodInfo{
		"CreateVideo":       kitex.NewMethodInfo(createVideoHandler, newCreateVideoArgs, newCreateVideoResult, false),
		"GetVideosByUserId": kitex.NewMethodInfo(getVideosByUserIdHandler, newGetVideosByUserIdArgs, newGetVideosByUserIdResult, false),
		"GetVideosByTime":   kitex.NewMethodInfo(getVideosByTimeHandler, newGetVideosByTimeArgs, newGetVideosByTimeResult, false),
		"LikeVideo":         kitex.NewMethodInfo(likeVideoHandler, newLikeVideoArgs, newLikeVideoResult, false),
		"UnLikeVideo":       kitex.NewMethodInfo(unLikeVideoHandler, newUnLikeVideoArgs, newUnLikeVideoResult, false),
		"CreateComment":     kitex.NewMethodInfo(createCommentHandler, newCreateCommentArgs, newCreateCommentResult, false),
		"DeleteComment":     kitex.NewMethodInfo(deleteCommentHandler, newDeleteCommentArgs, newDeleteCommentResult, false),
		"GetComments":       kitex.NewMethodInfo(getCommentsHandler, newGetCommentsArgs, newGetCommentsResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "video",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.3.1",
		Extra:           extra,
	}
	return svcInfo
}

func createVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto2.CreateVideoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto2.VideoService).CreateVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateVideoArgs:
		success, err := handler.(videoproto2.VideoService).CreateVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateVideoResult)
		realResult.Success = success
	}
	return nil
}
func newCreateVideoArgs() interface{} {
	return &CreateVideoArgs{}
}

func newCreateVideoResult() interface{} {
	return &CreateVideoResult{}
}

type CreateVideoArgs struct {
	Req *videoproto2.CreateVideoReq
}

func (p *CreateVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateVideoArgs) Unmarshal(in []byte) error {
	msg := new(videoproto2.CreateVideoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateVideoArgs_Req_DEFAULT *videoproto2.CreateVideoReq

func (p *CreateVideoArgs) GetReq() *videoproto2.CreateVideoReq {
	if !p.IsSetReq() {
		return CreateVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type CreateVideoResult struct {
	Success *videoproto2.CreateVideoResp
}

var CreateVideoResult_Success_DEFAULT *videoproto2.CreateVideoResp

func (p *CreateVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateVideoResult) Unmarshal(in []byte) error {
	msg := new(videoproto2.CreateVideoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateVideoResult) GetSuccess() *videoproto2.CreateVideoResp {
	if !p.IsSetSuccess() {
		return CreateVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto2.CreateVideoResp)
}

func (p *CreateVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getVideosByUserIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto2.GetVideosByUserIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto2.VideoService).GetVideosByUserId(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetVideosByUserIdArgs:
		success, err := handler.(videoproto2.VideoService).GetVideosByUserId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetVideosByUserIdResult)
		realResult.Success = success
	}
	return nil
}
func newGetVideosByUserIdArgs() interface{} {
	return &GetVideosByUserIdArgs{}
}

func newGetVideosByUserIdResult() interface{} {
	return &GetVideosByUserIdResult{}
}

type GetVideosByUserIdArgs struct {
	Req *videoproto2.GetVideosByUserIdReq
}

func (p *GetVideosByUserIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetVideosByUserIdArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetVideosByUserIdArgs) Unmarshal(in []byte) error {
	msg := new(videoproto2.GetVideosByUserIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetVideosByUserIdArgs_Req_DEFAULT *videoproto2.GetVideosByUserIdReq

func (p *GetVideosByUserIdArgs) GetReq() *videoproto2.GetVideosByUserIdReq {
	if !p.IsSetReq() {
		return GetVideosByUserIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetVideosByUserIdArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetVideosByUserIdResult struct {
	Success *videoproto2.GetVideosByUserIdResp
}

var GetVideosByUserIdResult_Success_DEFAULT *videoproto2.GetVideosByUserIdResp

func (p *GetVideosByUserIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetVideosByUserIdResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetVideosByUserIdResult) Unmarshal(in []byte) error {
	msg := new(videoproto2.GetVideosByUserIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetVideosByUserIdResult) GetSuccess() *videoproto2.GetVideosByUserIdResp {
	if !p.IsSetSuccess() {
		return GetVideosByUserIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetVideosByUserIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto2.GetVideosByUserIdResp)
}

func (p *GetVideosByUserIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getVideosByTimeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto2.GetVideosByTimeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto2.VideoService).GetVideosByTime(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetVideosByTimeArgs:
		success, err := handler.(videoproto2.VideoService).GetVideosByTime(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetVideosByTimeResult)
		realResult.Success = success
	}
	return nil
}
func newGetVideosByTimeArgs() interface{} {
	return &GetVideosByTimeArgs{}
}

func newGetVideosByTimeResult() interface{} {
	return &GetVideosByTimeResult{}
}

type GetVideosByTimeArgs struct {
	Req *videoproto2.GetVideosByTimeReq
}

func (p *GetVideosByTimeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetVideosByTimeArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetVideosByTimeArgs) Unmarshal(in []byte) error {
	msg := new(videoproto2.GetVideosByTimeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetVideosByTimeArgs_Req_DEFAULT *videoproto2.GetVideosByTimeReq

func (p *GetVideosByTimeArgs) GetReq() *videoproto2.GetVideosByTimeReq {
	if !p.IsSetReq() {
		return GetVideosByTimeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetVideosByTimeArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetVideosByTimeResult struct {
	Success *videoproto2.GetVideosByTimeResp
}

var GetVideosByTimeResult_Success_DEFAULT *videoproto2.GetVideosByTimeResp

func (p *GetVideosByTimeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetVideosByTimeResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetVideosByTimeResult) Unmarshal(in []byte) error {
	msg := new(videoproto2.GetVideosByTimeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetVideosByTimeResult) GetSuccess() *videoproto2.GetVideosByTimeResp {
	if !p.IsSetSuccess() {
		return GetVideosByTimeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetVideosByTimeResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto2.GetVideosByTimeResp)
}

func (p *GetVideosByTimeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func likeVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto2.LikeVideoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto2.VideoService).LikeVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *LikeVideoArgs:
		success, err := handler.(videoproto2.VideoService).LikeVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LikeVideoResult)
		realResult.Success = success
	}
	return nil
}
func newLikeVideoArgs() interface{} {
	return &LikeVideoArgs{}
}

func newLikeVideoResult() interface{} {
	return &LikeVideoResult{}
}

type LikeVideoArgs struct {
	Req *videoproto2.LikeVideoReq
}

func (p *LikeVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in LikeVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *LikeVideoArgs) Unmarshal(in []byte) error {
	msg := new(videoproto2.LikeVideoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LikeVideoArgs_Req_DEFAULT *videoproto2.LikeVideoReq

func (p *LikeVideoArgs) GetReq() *videoproto2.LikeVideoReq {
	if !p.IsSetReq() {
		return LikeVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LikeVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type LikeVideoResult struct {
	Success *videoproto2.LikeVideoResp
}

var LikeVideoResult_Success_DEFAULT *videoproto2.LikeVideoResp

func (p *LikeVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in LikeVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *LikeVideoResult) Unmarshal(in []byte) error {
	msg := new(videoproto2.LikeVideoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LikeVideoResult) GetSuccess() *videoproto2.LikeVideoResp {
	if !p.IsSetSuccess() {
		return LikeVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LikeVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto2.LikeVideoResp)
}

func (p *LikeVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func unLikeVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto2.UnLikeVideoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto2.VideoService).UnLikeVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UnLikeVideoArgs:
		success, err := handler.(videoproto2.VideoService).UnLikeVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnLikeVideoResult)
		realResult.Success = success
	}
	return nil
}
func newUnLikeVideoArgs() interface{} {
	return &UnLikeVideoArgs{}
}

func newUnLikeVideoResult() interface{} {
	return &UnLikeVideoResult{}
}

type UnLikeVideoArgs struct {
	Req *videoproto2.UnLikeVideoReq
}

func (p *UnLikeVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UnLikeVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UnLikeVideoArgs) Unmarshal(in []byte) error {
	msg := new(videoproto2.UnLikeVideoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnLikeVideoArgs_Req_DEFAULT *videoproto2.UnLikeVideoReq

func (p *UnLikeVideoArgs) GetReq() *videoproto2.UnLikeVideoReq {
	if !p.IsSetReq() {
		return UnLikeVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnLikeVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type UnLikeVideoResult struct {
	Success *videoproto2.UnLikeVideoResp
}

var UnLikeVideoResult_Success_DEFAULT *videoproto2.UnLikeVideoResp

func (p *UnLikeVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UnLikeVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UnLikeVideoResult) Unmarshal(in []byte) error {
	msg := new(videoproto2.UnLikeVideoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnLikeVideoResult) GetSuccess() *videoproto2.UnLikeVideoResp {
	if !p.IsSetSuccess() {
		return UnLikeVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnLikeVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto2.UnLikeVideoResp)
}

func (p *UnLikeVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func createCommentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto2.CreateCommentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto2.VideoService).CreateComment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateCommentArgs:
		success, err := handler.(videoproto2.VideoService).CreateComment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateCommentResult)
		realResult.Success = success
	}
	return nil
}
func newCreateCommentArgs() interface{} {
	return &CreateCommentArgs{}
}

func newCreateCommentResult() interface{} {
	return &CreateCommentResult{}
}

type CreateCommentArgs struct {
	Req *videoproto2.CreateCommentReq
}

func (p *CreateCommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateCommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateCommentArgs) Unmarshal(in []byte) error {
	msg := new(videoproto2.CreateCommentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateCommentArgs_Req_DEFAULT *videoproto2.CreateCommentReq

func (p *CreateCommentArgs) GetReq() *videoproto2.CreateCommentReq {
	if !p.IsSetReq() {
		return CreateCommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateCommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type CreateCommentResult struct {
	Success *videoproto2.CreateCommentResp
}

var CreateCommentResult_Success_DEFAULT *videoproto2.CreateCommentResp

func (p *CreateCommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateCommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateCommentResult) Unmarshal(in []byte) error {
	msg := new(videoproto2.CreateCommentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateCommentResult) GetSuccess() *videoproto2.CreateCommentResp {
	if !p.IsSetSuccess() {
		return CreateCommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateCommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto2.CreateCommentResp)
}

func (p *CreateCommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func deleteCommentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto2.DeleteCommentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto2.VideoService).DeleteComment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteCommentArgs:
		success, err := handler.(videoproto2.VideoService).DeleteComment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteCommentResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteCommentArgs() interface{} {
	return &DeleteCommentArgs{}
}

func newDeleteCommentResult() interface{} {
	return &DeleteCommentResult{}
}

type DeleteCommentArgs struct {
	Req *videoproto2.DeleteCommentReq
}

func (p *DeleteCommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeleteCommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteCommentArgs) Unmarshal(in []byte) error {
	msg := new(videoproto2.DeleteCommentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteCommentArgs_Req_DEFAULT *videoproto2.DeleteCommentReq

func (p *DeleteCommentArgs) GetReq() *videoproto2.DeleteCommentReq {
	if !p.IsSetReq() {
		return DeleteCommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteCommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type DeleteCommentResult struct {
	Success *videoproto2.DeleteCommentResp
}

var DeleteCommentResult_Success_DEFAULT *videoproto2.DeleteCommentResp

func (p *DeleteCommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeleteCommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteCommentResult) Unmarshal(in []byte) error {
	msg := new(videoproto2.DeleteCommentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteCommentResult) GetSuccess() *videoproto2.DeleteCommentResp {
	if !p.IsSetSuccess() {
		return DeleteCommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteCommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto2.DeleteCommentResp)
}

func (p *DeleteCommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getCommentsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoproto2.GetCommentsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoproto2.VideoService).GetComments(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetCommentsArgs:
		success, err := handler.(videoproto2.VideoService).GetComments(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetCommentsResult)
		realResult.Success = success
	}
	return nil
}
func newGetCommentsArgs() interface{} {
	return &GetCommentsArgs{}
}

func newGetCommentsResult() interface{} {
	return &GetCommentsResult{}
}

type GetCommentsArgs struct {
	Req *videoproto2.GetCommentsReq
}

func (p *GetCommentsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetCommentsArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetCommentsArgs) Unmarshal(in []byte) error {
	msg := new(videoproto2.GetCommentsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetCommentsArgs_Req_DEFAULT *videoproto2.GetCommentsReq

func (p *GetCommentsArgs) GetReq() *videoproto2.GetCommentsReq {
	if !p.IsSetReq() {
		return GetCommentsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetCommentsArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetCommentsResult struct {
	Success *videoproto2.GetCommentsResp
}

var GetCommentsResult_Success_DEFAULT *videoproto2.GetCommentsResp

func (p *GetCommentsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetCommentsResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetCommentsResult) Unmarshal(in []byte) error {
	msg := new(videoproto2.GetCommentsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetCommentsResult) GetSuccess() *videoproto2.GetCommentsResp {
	if !p.IsSetSuccess() {
		return GetCommentsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetCommentsResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoproto2.GetCommentsResp)
}

func (p *GetCommentsResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreateVideo(ctx context.Context, Req *videoproto2.CreateVideoReq) (r *videoproto2.CreateVideoResp, err error) {
	var _args CreateVideoArgs
	_args.Req = Req
	var _result CreateVideoResult
	if err = p.c.Call(ctx, "CreateVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetVideosByUserId(ctx context.Context, Req *videoproto2.GetVideosByUserIdReq) (r *videoproto2.GetVideosByUserIdResp, err error) {
	var _args GetVideosByUserIdArgs
	_args.Req = Req
	var _result GetVideosByUserIdResult
	if err = p.c.Call(ctx, "GetVideosByUserId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetVideosByTime(ctx context.Context, Req *videoproto2.GetVideosByTimeReq) (r *videoproto2.GetVideosByTimeResp, err error) {
	var _args GetVideosByTimeArgs
	_args.Req = Req
	var _result GetVideosByTimeResult
	if err = p.c.Call(ctx, "GetVideosByTime", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) LikeVideo(ctx context.Context, Req *videoproto2.LikeVideoReq) (r *videoproto2.LikeVideoResp, err error) {
	var _args LikeVideoArgs
	_args.Req = Req
	var _result LikeVideoResult
	if err = p.c.Call(ctx, "LikeVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnLikeVideo(ctx context.Context, Req *videoproto2.UnLikeVideoReq) (r *videoproto2.UnLikeVideoResp, err error) {
	var _args UnLikeVideoArgs
	_args.Req = Req
	var _result UnLikeVideoResult
	if err = p.c.Call(ctx, "UnLikeVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateComment(ctx context.Context, Req *videoproto2.CreateCommentReq) (r *videoproto2.CreateCommentResp, err error) {
	var _args CreateCommentArgs
	_args.Req = Req
	var _result CreateCommentResult
	if err = p.c.Call(ctx, "CreateComment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteComment(ctx context.Context, Req *videoproto2.DeleteCommentReq) (r *videoproto2.DeleteCommentResp, err error) {
	var _args DeleteCommentArgs
	_args.Req = Req
	var _result DeleteCommentResult
	if err = p.c.Call(ctx, "DeleteComment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetComments(ctx context.Context, Req *videoproto2.GetCommentsReq) (r *videoproto2.GetCommentsResp, err error) {
	var _args GetCommentsArgs
	_args.Req = Req
	var _result GetCommentsResult
	if err = p.c.Call(ctx, "GetComments", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
